==  Nuvolaris CLI 

The `nuv` command is the commnd line interface to Nuvolaris and let's you to manipulate the components of the system.

To start working with you have to login in some Nuvolaris installation. The administrator should have provided with username, password and the URL to access the system. For example,  you are the user `msciab` and the system is available on `https://nuvolaris.dev`.

In order to login type the folowing and enter you password.

----
nuv -login https://nuvolaris.dev max
Enter Password: 
----

If the password is correct you are logged in the system and you can use the commands described below.


=== Overview 

Nuvolaris applications are composed by some "entities" that you can manipulate either using a command line interface or programmatically with code. 

The command line interface is the `nuv` command line tools, that can be used directly on the command line or automated through scripts. You can also a REST API crafted explicitly for Nuvolaris. 

The entities available in Nuvolaris are:

* *Packages*: They serve as a means of grouping actions together, facilitating the sharing of parameters, annotations, etc. Additionally, they offer a base URL that can be utilized by web applications.
* *Actions*: These are the fundamental components of a Nuvolaris application, capable of being written in any programming language. Actions accept input and produce output, both formatted in JSON.
* *Sequences*: Actions can be interconnected, where the output of one action serves as the input for another, effectively forming a sequence.
* *Triggers*: Serving as entry points with distinct names, triggers are instrumental in activating multiple actions.
* *Rules*: Rules establish an association between a trigger and an action. Consequently, when a trigger is fired, all associated actions are invoked accordingly.
* *Feeds*: These are specialized actions which must implement a pattern to send events delivered to actions through triggers and rules. In a sense they are the source of a triggers.

=== The `nuv` command

Let's now provide an overview of Nuvolaris' command line interface, focusing on the `nuv` command.

The command can be dowloaded in precompile binary format for many platform following the `Download` button on  https://www.nuvolaris.io/


The `nuv` command is composed of many commands, each one with many subcommands. The general format is: 

----
nuv <entity> <command> <parameters> <flags>
----

Note that `<paramtes>` and `<flags>` are different for each `<command>`, and for each `<entity>` there are many subcommands.

The CLI shows documention in the form of help output if you do not provide enough parameters to it.  Start with  `nuv` to get the list of the main commands.  If you type the `nuv <entity>` get the help for that entity, and so on. 

For example, let's see `nuv` output (showing the command)  and the more frequently used command, `action`, also showing the more common subcommands, shared with many others:

----
$ nuv
Welcome to Nuv, the all-mighty Nuvolaris Build Tool

The top level commands all have subcommands.
Just type nuv <command> to see its subcommands.

Commands:
  action      work with actions
  activation  work with activations
  invoke      shorthand for action invoke (-r is the default)
  logs        shorthand for activation logs
  package     work with packages
  result      shorthand for activation result
  rule        work with rules
  trigger     work with triggers
  url         get the url of a web action$ wsk action
----

There are many more sub commands used for aministrative purposes. In this documentation we only focus on the   subcommands used to manage the main entities of Nuvolaris.

[NOTE]
Keep in mind that commands represent entities, and their subcommands follow the CRUD model (Create, Retrieve via get/list, Update, Delete). This serves as a helpful mnemonic to understand the `nuv` command's functionality. While there are exceptions, these will be addressed throughout the chapter's discussion. Note however that some subcommand may have some specific flags.

==== Naming Entities

Let's see how entities are named.

Each user also has a  *namespace*, and everything a user creates, belongs to it. 

The namespace is usually created by a system administrator.

Under a namespace you can create triggers, rules, actions and packages.

Those entities will have a name like this:

* `/mirella/demo-triggger`
* `/mirella/demo-rule`
* `/mirella/demo-package`
* `/mirella/demo-action`

When you create a package, you can put under it actions and feeds.  Those entities are named


*  `/mirella/demo-package/demo-action`
*  `/mirella/demo-package/demo-feed`

[NOTE]
In the commands you do not require to specify a namespace. If your user is `mirella`, your namespace is `/mirella`, and  You type `demo-package` to mean `/mirella/demo-package`, and `demo-package/demo-action` to mean `/mirella/demo-package/demo-action`.

=== Managing Packages

Nuvolaris groups actions and feeds in  *packages*  under a namespace.  A package lets you to:

* group related actions together
* share parameters and annotations (each action sees the parameters assigned to the package) 
* provide to web actions a common prefix in the URL to invoke them.

We can for example create a package `demo-package` and assign a parameter:


----
$ wsk package create demo-package -p email no-reply@nuvolaris.io
ok: created package demo-package
----

Let's go on with the commands to list, get informations, update it and finally delete a package:


----
$ nuv package list
packages
/mirella/demo-package/demo-action                               private
$ nuv package update demo-package -p email info@nuvolaris.io
ok: updated package demo-package
$ nuv package get demo-package -s                     
package /mirella/demo-package/sample: Returns a result based on parameter email
   (parameters: *email)
$ nuv package delete demo-package
ok: deleted package demo-package
----

Note the `-s` flag to mean `summarize`.

=== Managing Actions

The `nuv action` command is designed for managing actions, featuring the frequently utilized CRUD operations such as list, create, update, and delete. We will illustrate these operations through examples using a basic hello action. Let's assume we have the following file in current directory


.The `hello.js` script
----
function main(args) {
  return { body: "Hello" }
}
----

If we want to deploy this simple action in the package `demo` let's execute:

----
$ nuv package update demo                  
ok: updated package demo
$ nuv action update demo/hello hello.js
ok: update action demo/hello
----

Note we ensured the package exists before creating the action. 

We can actually omit the package name. In this case the package name is `default` that always exists in a namespace. However we advice to always place actions in some named package. 

[NOTE]
We used `update` but we could have used `create` if the actions does not exists, because `update` also creates the action if does not exists and `update` if it is already there. However, `creates` generates an error if an action does not exist while `update` does not, so it is practical to alwasy use `update` insteand of `create` (unless we really want an error for an existing action for some reasons).

XXXX

Once the action 
----
$ wsk action invoke basics/now
ok: invoked /_/basics/now with id fec047bc81ff40bc8047bc81ff10bc85
----

Wait a minute... where is the result? Actually, actions in OpenWhisk are by default asynchronous, so what you get usually is just an *id* (called *activation id*) to retrieve the result after the action completed. We discuss activations in detail in the next paragraph. 

If we instead we want to see the result immediately, we can provide the flag `-r` or `--result`. It blocks until we get an answer. So:


----
$ wsk action invoke basics/now -r
{
    "body": "Thu Mar 15 2018 14:24:39 GMT+0000 (UTC)"
}
----


Great. However, what is if want to access that action from the web? We can retrieve an URL with `get` and `--url`. 

If we leave out the `--url` we get a complete description of the action in JSON format:

----
$ wsk action get basics/now --url
https://openwhisk.eu-gb.bluemix.net/api/v1/namespaces/openwhisk@example.com_dev/actions/basics/now
$ wsk action get basics/now
{
    "namespace": "openwhisk@example.com_dev/basics",
    "name": "now",
    "version": "0.0.1",
    "exec": {
        "kind": "nodejs:6",
        "binary": false
    },
    "annotations": [
        {
            "key": "exec",
            "value": "nodejs:6"
        }
    ],
    "limits": {
        "timeout": 60000,
        "memory": 256,
        "logs": 10
    },
    "publish": false
}
----

However, if we try to use the URL to run the action we may have a nasty surprise:

----
$ curl https://openwhisk.eu-gb.bluemix.net/api/v1/\
namespaces/openwhisk@example.com_dev/actions/basics/now
{"error":"The resource requires authentication,\
 which was not supplied with the request" 
 "code":9814}
----

The fact is: all the actions (and everything else) in OpenWhisk is accessible with a REST API. However, by default, the actions are protected and not accessible without authentication. 

However, it is possible to mark an action as publicly accessible with the flag `--web true` flag when creating or updating it. We call them *web actions*.

A web action is supposed to produce web output so that you can view with a web browser.  There are some other constraints on Web action we discuss later. For now, focus on the fact the answer must have a `body` property that is rendered as the body of an HTML page.

Now, since our action was not a web one, we must change it. This case is an opportunity to demonstrate how the `update` command that can change an action. Then we can immediately retrieve its URL and invoke it directly.

----
$ wsk action update basics/now --web true
ok: updated action basics/now
$ curl $(wsk action get basics/now --url | tail -1)
Thu Mar 15 2018 14:46:56 GMT+0000 (UTC)
----

We saw the `create` and `update` commands for managing actions. We now complete the demonstration of the `CRUD` commands also showing the `list` and the `delete` command:


----
$ wsk action list basics
actions
/openwhisk@example.com_dev/basics/now                               private nodejs:6
$ wsk action delete basics/now
ok: deleted action basics/now
$ wsk action list basics
actions
----

==== Chain Sequences of Actions

An essential feature of OpenWhisk is the ability to chain action in sequences, creating actions that use, as an input, the output of another action, as shown in  <<sequences>>.

[id=sequences]
.Actions chained in a sequence
image::dot/sequences.dot.png[]

Let's do a practical example of a similar action sequence. We implement a word count application, separating it in two actions, put in a sequence. The first action splits the input, that is supposed to be a text file, in "words", while the second retrieves the words and produce a map as a result. In the map,  each word is then shown with its frequency.

Let's start with the first action, `split.js`, as follows:

----
function main(args) {
    let words = args.text.split(' ')
    return {
        "words": words
    }
}
----


You can deploy and test it, feeding a simple string:


----
$ wsk action update basics/split basics/split.js
ok: updated action basics/split
$ wsk action invoke basics/split \
  -p text "the pen is on the table" -r \
  | tee save.json <1>
{
    "words": [
        "the",
        "pen",
        "is",
        "on",
        "the",
        "table"
    ]
}
----
<1> note here we are saving the output in a file `save.json`


Now it is time to do the second step, with this `count.js` actions:

----
function main(args) {
    let words = args.words
    let map = {}
    let n = 0
    for(word of words) {
       n = map[word]
       map[word] = n ? n+1 : 1
    }
    return map
}
----


We can now deploy it and check the result, feeding the output of the first action as input:

----
$ wsk action update basics/count count.js
ok: updated action basics/count
$ wsk action invoke basics/count -P save.json -r
{
    "is": 1,
    "on": 1,
    "pen": 1,
    "table": 1,
    "the": 2
}
----


Now we have two actions, the second able to take the output of the first as input,  we can create a sequence:

----
wsk action update basics/wordcount \
  --sequence basics/split,basics/count <1>
----
<1> note here we are specifying a comma-separated list of existing action names

The sequence can be now invoked as a single action, so we can feed the text input and see the result:

----
$ wsk action invoke basics/wordcount -r -p text  \
"can you can a can as a canner can can a can"
{
    "a": 3,
    "as": 1,
    "can": 6,
    "canner": 1,
    "you": 1
}
----

[id=actions-including-libraries]
==== Actions including Libraries

In the simplest case, your action is just a single javascript file. However, as we are going to see, very often commonly you have some code you want to share and reuse between actions.

The best way to handle this situation is to have a library of code that you can include for every action and that you deploy with your actions.

Let's consider this example: a couple of utility functions that format a date in a standard format "YYYY/MM/DD" and time in the standard format "HH:MM:SS".


[id=format-date-time]
.Formatting date and time utility functions
----
function fmtDate(d) {
    let month = '' + (d.getMonth() + 1),
        day = '' + d.getDate(),
        year = d.getFullYear();
    if (month.length < 2) month = '0' + month;
    if (day.length < 2) day = '0' + day;
    return year + "/" + month + "/" + day
}

function fmtTime(d) {
    let hour =  ''+ d.getHours(),
        minute = '' + d.getMinutes()
        second = '' + d.getSeconds()

    if(hour.length < 2) hour = "0"+hour
    if(minute.length < 2) minute = "0"+minute
    if(second.length <2 ) second = "0"+second

    return hour + ":" + minute + ":" + second
}
----


You may, of course, copy this code in each action file, although it is pretty awkward to maintain. Just consider that when you change the function, you have to change it in all the copies of the functions across multiple files. Of course, there is a better way.


Since actions are executed using NodeJs, you have the standard export/require mechanism available for writing your actions. 


As a convention, we are going to place our shared code in a subdirectory named `lib`, and we treat them as modules. 


So you should place the <<format-date-time>> in a file `lib/datetime.js` and add at the end the following code:


----
module.exports = {
    fmtTime: fmtTime,
    fmtDate: fmtDate
}
----

Now you can use the two functions in one action. For example let consider an action named `clock` that returns the date if invoked with `date=true`, the time if invoked with `time=true`, or both if the date and time parameters are specified.


Our action will starts requiring the library with:

----
var dt = require("./lib/datetime.js")
----

This way you can access the two functions as `dt.fmtDate` and `dt.fmtTime`. Using those functions, we can easily write the main body, called `clock.js`:

----
function main(args) { 
  let now = args.millis ? new Date(args.millis) : new Date()
  let res = " "
  if(args.date)
    res = dt.fmtDate(now) + res
  if(args.time)
    res = res + dt.fmtTime(now)
  return {     
    body: res
  }
}
exports.main = main
----

Now, we have to deploy the action, but we also need to include the library. How can we do this in OpenWhisk?

The solution is to deploy not a single file but a zip file that includes all the files we want to run as a single action.

When deploying multiple files, you need either to put your code in a file `index.js` or to provide a `package.json` saying which one is the main file.

Let's perform this procedure with the following commands, creating a `package.json` inline, then a zip file and finally deploying it all. The final content of the `clock.zip` will be:

----
├── clock.js
├── lib
│   └── datetime.js
└── package.json
----

Let's build and deploy it:

----
$ cd basics
$ echo '{"main":"clock.js"}' >package.json      <1>
$ zip -r clock.zip clock.js package.json lib    <2>
$ wsk action update basics/clock clock.zip \
  --kind nodejs:6                               <3>
ok: updated action basics/clock
----
<1> creating a simple `package.json` on the fly
<2> creating a zip file with subdirectories, so the `-r` switch is required
<3> deploying the action, specifying the runtime we want to use is `nodejs:6` 

[NOTE]
When we deploy an action as a zip file, we have to specify the runtime to use with `--kind nodejs:6`,  because the system is unable to figure out by itself just from the file name.

Let's test it:

----
$ wsk action invoke basics/clock -p date true -r
{
    "body": "2018/03/18 "
}
$ wsk action invoke basics/clock -p time true -r
{
    "body": " 15:40:42"
}
----
=== Inspect Activations

In the preceding paragraph, we saw when we invoke an action without waiting for the result; we receive as an answer just an invocation id.

This fact brings us to the argument of this paragraph: the subcommand `wsk activation` to manage the results of invocations.


To explore it, let's create a simple `echo.js` file:


.A simple echo with logging for testing activations
----
function main(args) {
 console.log(args)
 return args
}
----


Now, let's deploy and invoke it (with a parameter `hello=world`) to get the activation id:

----
$ wsk action create basics/echo echo.js
ok: created action basics/echo
$ wsk action invoke basics/echo -p hello world
ok: invoked /_/basics/echo with id 82deb0ec37524a9e9eb0ec37525a9ef1
----


As we explained in Chapter 1, when actions are invoked, they are identified by an activation id, used to save and retrieve results and logs from the database.

Now, the long alphanumeric (actually, hexadecimal) identifier displayed is the activation id. We can now use with it the option `result` to get the result, and `logs` to get the logs.

----
$ ID=$(wsk action invoke basics/echo -p hello world \
  | awk '{ print $6}')
$ wsk activation result $ID
{
    "hello": "world"
}
$ wsk activation logs $ID
2018-03-15T18:17:36.551486467Z stdout: { hello: 'world' }
----

[TIP]
You can also use the `wsk result --last` to get the result of the last invoked action.

The `activation` subcommand has another two useful options. 

One is `list`. It will return a list of *all* the activations in chronological order. Since the list can be very long, it is useful always to use the option `--limit <n>` to see only the latest `<n>`:

----
$ wsk activation list --limit 4
activations
82deb0ec37524a9e9eb0ec37525a9ef1 echo
219bacbdb838449d9bacbdb838149de2 echo
1b75cd02fd1f4782b5cd02fd1f078284 echo
6fa117115aa74f90a117115aa7cf90e0 now
----

Another useful option (and probably the most useful)  is `poll`. With this option, you can continuously display logs for actions as they happen.  It is a handy option for debugging because let you to monitor what is going on in the remote serverless system.

[TIP]
You can poll for just an action or for all the actions at the same time.

=== Manage Triggers and Rules

Now let's see how to create a trigger. 

A trigger is merely a name for an arbitrary event. A trigger by itself does nothing. However with the help of rules, it becomes useful, because when a trigger is activated, it invokes all the associated rules, as shown in <<triggers>>.

[id=triggers]
.Triggers and rules
image::dot/triggers-rules.dot.png[]

Let's build now an example to see what triggers do. We use a simple action that does nothing except logging its activation. We use it to trace what is happening when you activate triggers. Note we start to construct the example now, but we complete it after we introduced rules, in the next paragraph.

So, let's prepare our example, deploying first a simple `log.js` actions, that just logs its name:

----
function main(args) {
 console.log(args.name)
 return {}
}
----

Then, we  deploy it twice, with two different names:

----
$ wsk action update basics/log-alpha -p name alpha basics/log.js
ok: updated action basics/log-alpha
$ wsk action update basics/log-beta -p name beta basics/log.js
ok: updated action basics/log-alpha
----

By themselves, those actions do nothing except leaving a trace of their activation in the logs:

----
$ wsk action invoke basics/log-alpha                 <1>
ok: invoked /_/basics/log-alpha with id 320b50d841064d0b8b50d841060d0bff
$ wsk action invoke basics/log-beta                  <2>
ok: invoked /_/basics/log-beta with id 990d284f090c45328d284f090c45320d
$ wsk activation list --limit 2                      <3>
activations 
990d284f090c45328d284f090c45320d log-beta
320b50d841064d0b8b50d841060d0bff log-alpha
$ wsk activation poll --since-seconds 60 --exit 20   <4>
Enter Ctrl-c to exit.
Polling for activation logs
Activation: 'log-beta' (e6b76a85c5584579b76a85c558957957)
[
    "2018-03-17T17:32:06.364836123Z stdout: beta"
]
Activation: 'log-alpha' (e92e4466ee8f4684ae4466ee8f6684da)
[
    "2018-03-17T17:32:00.842842699Z stdout: alpha"
]
----
<1> invoking the action `log-alpha`
<2> invoking the action `log-beta`
<3> showing a list of activations
<4> poll the activations (since 60 seconds, for 20 seconds) to see which activations happened and what they logged

Now we are ready to create a trigger, using the command `wsk trigger create` as in <<creating-trigger>>.

[NOTE]
Of course, there is not only `create` but also `update` and  `delete`, and they work as expected, updating and deleting triggers. In the next paragraph, we see also the `fire` command, that needs you first create rules to do something useful.

[id=creating-trigger]
.Creating a trigger and inspecting it
----
$ wsk trigger create basics-alert
ok: created trigger alert
$ wsk trigger list
triggers
/openwhisk@example.com_dev/basics-alert                                     private
$ wsk trigger get basics-alert
ok: got trigger alert
{
    "namespace": "openwhisk@example.com_dev",
    "name": "basics-alert",
    "version": "0.0.1",
    "limits": {},
    "publish": false
}
----

[WARNING]
Triggers are a "namespace level" entity, and you cannot put them in a package.

==== Associate Triggers to Actions with Rules

Once we have a trigger and some actions we can create rules for the trigger. A rule connects the trigger with an action, so if you fire the trigger, it will invoke the action.  Let's see in practice in next listing.

[id=creating-rules]
.An example of creating a rule, triggering an event and inspecting the logs.
----
$ wsk rule create basics-alert-alpha \
       basics-alert basics/log-alpha                      <1>
ok: created rule basics-alert-alpha
$ wsk trigger fire basics-alert                           <2>      
ok: triggered /_/alert with id 86b8d33f64b845f8b8d33f64b8f5f887
$ wsk activation logs 86b8d33f64b845f8b8d33f64b8f5f887 \  <3>
   | jq                                                   <4>
{
  "statusCode": 0,
  "success": true,
  "activationId": "b57a1f1dc3414b06ba1f1dc341ab0626",     <5>
  "rule": "openwhisk@example.com_dev/basics-alert-alpha",
  "action": "openwhisk@example.com_dev/basics/alpha"
}

$ wsk activation logs b57a1f1dc3414b06ba1f1dc341ab0626    <6>
2018-03-17T18:10:48.471777977Z stdout: alpha
----
<1> creating a rule to activate the action `basics/log-alpha` when the trigger `basics-alert` is fired
<2> we can now fire the rule, it returns an activation id
<3> let's inspect the activation id 
<4> we piped the output in the `jq` utility to make the output more readable
<5> in turn the rule invoked an action with this activation id
<6> let's see what the rule did


[NOTE]
As for all the other commands, you can execute `list, `update` and `delete` by name.

A trigger can enable multiple rules, so firing one trigger actually activates multiple actions. 

Let's try this feature. However, before starting, let's open another terminal window and enable polling (with the command `wsk activation poll`) to see what happens.

----
$ wsk rule create basics-alert-beta basics-alert basics/log-beta
ok: created rule basics-alert-beta
$ wsk trigger fire basics-alert
ok: triggered /_/basics-alert with id a731a03603bb4183b1a03603bb8183ce
----

If we check the logs we should see something like this:

----
$ wsk activation poll
Enter Ctrl-c to exit.
Polling for activation logs

Activation: 'alert' (a731a03603bb4183b1a03603bb8183ce)    <1>
[
    "{\"statusCode\":0,\"success\":true,\
    \"activationId\":\"3024596c57ac4c10a4596c57ac7c1042\",\
    \"rule\":\"openwhisk@example.com_dev/basics-alert-alpha\",\"action\":\"openwhisk@example.com_dev/basics/log-alpha\"}",
    "{\"statusCode\":0,\"success\":true,\
    \"activationId\":\"6d88836c860d405f88836c860d305f83\",\"rule\":\"openwhisk@example.com_dev/basics-alert-beta\",\
    \"action\":\"openwhisk@example.com_dev/basics/log-beta\"}"
]

Activation: 'log-alpha' (3024596c57ac4c10a4596c57ac7c1042) <2>
[
    "2018-03-17T18:34:58.633797676Z stdout: alpha"
]

Activation: 'log-beta' (6d88836c860d405f88836c860d305f83)  <3>
[
    "2018-03-17T18:34:58.629413468Z stdout: beta"
]
----
<1> The trigger activation invoked 2 actions
<2> This is the log of the first action
<3> This is the log of the second action


Rules can also be enabled and disabled without removing them. As the last example, we try to disable the first rule and fire the trigger again to see what happens. As before, first, we start the log polling to see what happened.

----
$ wsk rule disable basics-alert-alpha     <1>
ok: disabled rule basics-alert-alpha
$ wsk trigger fire basics-alert           <2>
ok: triggered /_/basics-alert with id 0f4fa69d910f4c738fa69d910f9c73af
----
<1> disabling rule alert-alpha
<2> firing the trigger again

Moreover, if we go and check the result, we see this time only the action `log-beta` was invoked.

----
$ wsk activation poll
Enter Ctrl-c to exit.
Polling for activation logs

Activation: 'basics-alert' (0f4fa69d910f4c738fa69d910f9c73af)
[
    "{\"statusCode\":0,\"success\":true,\"activationId\":\"a8221c7d7fe94e22a21c7d7fe9ce223c\",\
    \"rule\":\"openwhisk@example.com_dev/alert-beta\",\
    \"action\":\"openwhisk@example.com_dev/basics/log-beta\"}",
    "{\"statusCode\":1,\"success\":false,\
    \"rule\":\"openwhisk@example.com_dev/basics-alert-alpha\",\
    \"error\":\"Rule 'openwhisk@example.com_dev/basics-alert-alpha' is inactive, \
    action 'openwhisk@example.com_dev/basics/log-alpha' \
    was not activated.\",\
    \"action\":\"openwhisk@example.com_dev/basics/log-alpha\"}"
]

Activation: 'log-beta' (a8221c7d7fe94e22a21c7d7fe9ce223c)
[
    "2018-03-18T07:27:14.01530577Z  stdout: beta"
]
----
=== Create Feeds

Triggers are useful if someone can enable them. You can fire your triggers in code, as we will see when we examine the API. 

However triggers are really there to be invoked by third parties and hook them to our code. This feature is provided by the `feed` concept.

[id=feeds]
.Feeds triggering Actions
image::dot/feed.dot.png[]

A feed is actually an action that implements a pattern, not an API. We will see how to implement it in the example describing the "Observer" pattern. 

For now, we see how to hook an existing feed on the command line, creating a trigger invoked periodically.

For this purpose we use the `/whisk.system/alarm` package. If we inspect it, we see it offers a few actions that can be used as a periodical event source:

----
$ wsk action list /whisk.system/alarms
actions
/whisk.system/alarms/interval                                          private nodejs:6
/whisk.system/alarms/once                                              private nodejs:6
/whisk.system/alarms/alarm                                             private nodejs:6
----

The `once` feed will trigger an event only once, while the `interval` can provide it based on a fixed schedule. The `alarm` trigger is the more complex since it uses  a `cron` like expression (that we do not discuss here).

Let's create a trigger to be executed every minute  using `interval` and associate it to the rule `log-alpha`. As before, we start first the polling of the logs to see what happens.

----
$ wsk trigger create basics-interval \
  --feed /whisk.system/alarms/interval \           <1>
  --param minutes 1                                <2>
ok: invoked /whisk.system/alarms/interval with id 5d4bf01d0a56412d8bf01d0a56512d38
{
    "activationId": "5d4bf01d0a56412d8bf01d0a56512d38",
    "annotations": [
        {
            "key": "path",
            "value": "whisk.system/alarms/interval"
        },
        {
            "key": "waitTime",
            "value": 34
        },
        {
            "key": "kind",
            "value": "nodejs:6"
        },
        {
            "key": "limits",
            "value": {
                "logs": 10,
                "memory": 256,
                "timeout": 60000
            }
        },
        {
            "key": "initTime",
            "value": 320
        }
    ],
    "duration": 1153,
    "end": 1521359853176,
    "logs": [],
    "name": "basics-interval",
    "namespace": "openwhisk@example.com_dev",
    "publish": false,
    "response": {
        "result": {
            "status": "success"
        },
        "status": "success",
        "success": true
    },
    "start": 1521359852023,
    "subject": "openwhisk@example.com",
    "version": "0.0.6"
}
ok: created trigger interval

$ wsk rule create \                                 <3>
  basics-interval-alpha basics-interval basics/log-alpha
ok: created rule interval-alpha
----
<1> the parameter `--feed`  connects the trigger to the feed
<2> we pass a parameter to the feed, saying we want the trigger to be activated every minute
<3> the trigger does nothing until we associate it to action with a rule

If we now wait a couple of minutes this is what we will see in the activation log:

----
Polling for activation logs:

Activation: 'log-alpha' (0ca4ade11e73498fa4ade11e73a98ff0)
[
    "2018-03-18T08:01:03.046752324Z stdout: alpha"
]

Activation: 'basics-interval' (065c363456b440489c363456b4c04864)
[
    "{\"statusCode\":0,\"success\":true,\"activationId\":\"0ca4ade11e73498fa4ade11e73a98ff0\",\"rule\":\"openwhisk@example.com_dev/basics-interval-alpha\",\"action\":\"openwhisk@example.com_dev/basics/log-alpha\"}"
]
----

[WARNING]
After you do this test, do not forget to remove the trigger or it will stay there forever, consuming actions. You may even end up getting a bill for it! 

To remove the trigger and the rule:

----
$ wsk rule delete basics-interval-alpha
ok: deleted rule interval-alpha
$ wsk trigger delete basics-interval
ok: deleted trigger interval
----
