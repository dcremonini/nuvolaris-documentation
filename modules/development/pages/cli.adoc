==  Nuvolaris CLI 

Nuvolaris applications are composed by some "entities" that you can manipulate either using a command line interface or programmatically with code. 

The command line interface is the `nuv` command line tools, that can be used directly on the command line or automated through scripts. You can also a REST API crafted explicitly for Nuvolaris. 

The entities available in Nuvolaris are:

* *Packages*: They serve as a means of grouping actions together, facilitating the sharing of parameters, annotations, etc. Additionally, they offer a base URL that can be utilized by web applications.
* *Actions*: These are the fundamental components of a Nuvolaris application, capable of being written in any programming language. Actions accept input and produce output, both formatted in JSON.
* *Sequences*: Actions can be interconnected, where the output of one action serves as the input for another, effectively forming a sequence.
* *Triggers*: Serving as entry points with distinct names, triggers are instrumental in activating multiple actions.
* *Rules*: Rules establish an association between a trigger and an action. Consequently, when a trigger is fired, all associated actions are invoked accordingly.
* *Feeds*: These are specialized actions which must implement a pattern to send events delivered to actions through triggers and rules. In a sense they are the source of a triggers.

[id=the-nuv-command]
=== The `nuv` command

Now let's give an overview of the command line interface of Nuvolaris, namely the command `nuv`. 

The command can be dowloaded in precompile binary format for many platform following the `Download` button on  https://www.nuvolaris.io/.

XXXXXX


The `wsk` command is composed of many commands, each one with many subcommands. The general format is: 

----
wsk <COMMAND> <SUB-COMMAND> <PARAMETERS> <FLAGS>
----

Note that `<PARAMETERS>` and `<FLAGS>` are different for each `<SUBCOMMAND>`, and for each `<COMMAND>` there are many subcommands.

The CLI itself is self-documenting and provides help when you do not feed enough parameters to it.  Just typing `wsk` you get the list of the main commands. If you type the `wsk` command then the subcommand you get the help for that subcommand. 

For example, let's see `wsk` output (showing the command)  and the more frequently used command, `action`, also showing the more common subcommands, shared with many others:

----
$ wsk
Available Commands:
  action      work with actions
  activation  work with activations
  package     work with packages
  rule        work with rules
  trigger     work with triggers
  property    work with whisk properties
  namespace   work with namespaces
  list        list entities in the current namespace
$ wsk action
  create      create a new action             <1>
  update      update an existing action       <2>
  invoke      invoke action
  get         get action                      <3>
  delete      delete action                   <4>
  list        list all action                 <5>
----
<1> `create` available for actions, packages, rules and triggers
<2> `update` available for actions, packages, rules and triggers
<3> `get` available for actions, packages, rules and triggers, and also for activations, namespaces and properties
<4> `delete` available for actions, package, rule and triggers
<5> `list` available for actions, package, rule and triggers, and also for namespace and for everything.

[TIP]
Remembering that commands are the entities and the subcommands are C.R.U.D. (Create, get/list for Retrieve, Update, Delete)  gives you a good mnemonic of how the whole `wsk` command works.  Of course, there are individual cases, but we cover those in the discussion along the chapter.

Subcommands also have flags, some specific for the subcommand. In the rest of the paragraph, we discuss all the subcommands. We provide the details of interesting flags as we meet them.


==== Configure the wsk command

The `wsk` command has many "properties" you can configure to access to an OpenWhisk environment. When you use the IBM Cloud, those properties are actually set for you by the `ibmcloud` main command. If you have a different OpenWhisk deployment, you may need to change the properties manually to access it. 

You can see the currently configured properties with:

----
$ wsk property get
Client key
whisk auth            xxxxx:YYYYY                  <1>
whisk API host        openwhisk.eu-gb.bluemix.net  <2>
whisk API version    v1
whisk namespace        _                            <3>
whisk CLI version    2017-11-15T19:55:32+00:00
whisk API build        2018-02-28T23:44:25Z
whisk API build number    whisk-build-7922
----
<1> the API authentication  key (replaced in the example with `xxxxx:YYYYY`) - your own will be different
<2> the OpenWhisk host you connect to control OpenWhisk with the CLI - depends on your location
<3> your current namespace (the value `_` is a shorthand for you default namespace)

If you install a local OpenWhisk environment,  you need to set those properties using  `wsk property set` manually. In particular, you need to set the `whisk auth` and the `whisk host` properties with values provided by your local installation.
==== OpenWhisk Entity Names

Let's see how we name things. As you may already know, in OpenWhisk we have the following entities with a name:

* packages
* actions
* sequences
* triggers
* rules 
* feeds

There are precise naming conventions for them. Furthermore, those conventions are reflected in the structure of the URL used to invoke the various elements of OpenWhisk.

First and before all, each user is placed in a *namespace*, and everything a user creates, belong to it. It acts as a workspace and also provides a base URL for what a user creates. Credentials for a user allows access to all the resources in its namespace.

For example, when I registered in the IBM Cloud, my namespace was `/openwhisk@example.com_dev/`. It is  my username followed by `_dev` (for development). 

You can create a namespace in an OpenWhisk installation if you are authorized, otherwise, a namespace is created for you by the system administrator. 

Under a namespace you can create triggers, rules, actions and packages, so they will have names like:


* `/openwhisk@example.com_dev/a-triggger`
* `/openwhisk@example.com_dev/a-rule`
* `/openwhisk@example.com_dev/a-package`
* `/openwhisk@example.com_dev/an-action`

When you create a package, you can put in its actions and feeds. So for example  below the package `a-package` you can have:


*  `/openwhisk@example.com_dev/a-package/another-action`
*  `/openwhisk@example.com_dev/a-package/a-feed`


To recap:

* The general format for entities is: `/namespace/package/entity`, but it can be reduced to `/namespacke/entity`
* Under a `namespace` you can create triggers, rules, package, and actions but not feeds.
* Under a `package` you can create actions and feeds, but not triggers, rules, and other packages.


[NOTE]
Most of the time you do not need to specify the `namespace`. If you specify an action as a relative action (not starting with `/`) it will be placed in your current namespace. Note that the special namespace name of `_`  means "your current namespace" and the full namespace name automatically replace it.

=== Define Packages

In OpenWhisk, according to the naming conventions, all the `entities` are grouped in a *namespace*. We can put actions under a namespace. 

Under a namespace, you can create *packages* to bundle actions together. A package is useful for two main purposes:

* group related actions together, to reuse them and share with others;
* share parameters, annotations etc;
* provide base a URL to those related actions, useful for actions that refer each other, like in web applications. 

However, it is usually convenient to further groups actions. Packages are hence useful for grouping actions (and feeds, that are just actions too), treating them as a single unit. Furthermore, a package can also include parameters.


Let's do an example. We can just create a package `sample`, also providing a parameter, as follows.


----
$ wsk package create sample -p email michele@sciabarra.com
ok: created package sample
----

[TIP]
Parameters of a package are available to all the actions in a package.


Now you can `list` packages, `get` information from packages, `update` it (for example with different parameters) and finally  `delete` it.


----
$ wsk package list
packages
/openwhisk@example.com_dev/sample                                    private
/openwhisk@example.com_dev/contact                                   private
/openwhisk@example.com_dev/contactdb                                 private
$ wsk package update sample -p email openwhisk@example.com
ok: updated package sample
$ wsk package get sample -s                     <1>
package /openwhisk@example.com_dev/sample: Returns a result based on parameter email
   (parameters: *email)
$ wsk package delete sample
ok: deleted package sample
----
<1> here we used the parameter `-s` to summarize information from the package

Now let's see another essential function of a package: *binding*. 

OpenWhisk allows to import (or *bind*)  to your namespace, packages from a third party, to customize them for your purposes. 


[NOTE]
Keep in mind that credentials of a user allow access to all the resources under a namespace. As a result, to bind a package in our namespace has the effect of making it accessible to the other actions in the namespace. 

For example, let's review first the packages available in the IBM Cloud. Of course, this cloud includes their solution for everyday needs like databases and message queues. The database available in the IBM Cloud is a scalable version of the popular no-SQL database CouchDB, i.e., Cloudant. 

A package for Cloudant is available, as we can see below, and all we need to do to use it is to bind it. In the example below,  we use the configuration file `cloudant.json`. How to retrieve the configuration file is described in Chapter 2.

----
$ wsk package list /whisk.system
packages                                              <1>
/whisk.system/cloudant                                                 shared
/whisk.system/websocket                                                shared
/whisk.system/alarms                                                   shared
/whisk.system/messaging                                                shared
$ wsk package get /whisk.system/cloudant  -s | head -2 <2>
package /whisk.system/cloudant: Cloudant database service
   (parameters: *apihost, *bluemixServiceName, 
    *dbname, *host, overwrite, *password, *username)   <3>
$ wsk package bind /whisk.system/cloudant patterndb  \ <4>
    -P cloudant.json -p dbname pattern                 <5>
ok: created binding contactdb
----
<1> We are listing the packages available in the IBM Cloud. I edited and shortened the output for clarity.
<2> We are inspecting the Cloudant package. We are limiting to see only the first two lines, those describing the package.
<3> Note here the required parameters to use the database
<4> we created here the binding to make the database accessible
<5> We are using the file `cloudant.json` for the specifying `host`, `username` and `password`, and providing the `dbname` on the command line.

[TIP]
Two common flags, available also for actions, feed and triggers are `-p` and `-P`. With `-p <name> <value>` you can specify a parameter named `<name>` with value `<value>`. With the `-P` you can put some parameters in a JSON file that is assumed to be a map. Check paragraph <<pattern-prototype>> for an example of the format.

=== Create Actions

The command `wsk action` lets you manipulate actions. The more commonly used subcommands of this command are the CRUD actions to `list`, `create`,  `update` and `delete` actions. Let's demonstrate them with some examples.

We create and use a simple `now` action for our examples:

.The `now.js` script
----
function main(args) {
  return { body: Date() }
}
----

Now, if we want to deploy this simple action in the package `basics` we do:

----
$ wsk package update basics                   <1>
ok: updated package basics
$ wsk action create basics/now basics/now.js  <2>
ok: created action basics/now
----
<1> Ensuring we have a `basics` package
<2> Create the action from the file stored in  `basics/now.js`

[TIP]
You could omit the `basics` and place the action in the namespace and not in a package. We do not advise to do so, however, because gathering your actions in packages is always a good idea to improve modularity and reuse.

Now that the action has been deployed, we can invoke it. The simplest way is to call it as:

----
$ wsk action invoke basics/now
ok: invoked /_/basics/now with id fec047bc81ff40bc8047bc81ff10bc85
----

Wait a minute... where is the result? Actually, actions in OpenWhisk are by default asynchronous, so what you get usually is just an *id* (called *activation id*) to retrieve the result after the action completed. We discuss activations in detail in the next paragraph. 

If we instead we want to see the result immediately, we can provide the flag `-r` or `--result`. It blocks until we get an answer. So:


----
$ wsk action invoke basics/now -r
{
    "body": "Thu Mar 15 2018 14:24:39 GMT+0000 (UTC)"
}
----


Great. However, what is if want to access that action from the web? We can retrieve an URL with `get` and `--url`. 

If we leave out the `--url` we get a complete description of the action in JSON format:

----
$ wsk action get basics/now --url
https://openwhisk.eu-gb.bluemix.net/api/v1/namespaces/openwhisk@example.com_dev/actions/basics/now
$ wsk action get basics/now
{
    "namespace": "openwhisk@example.com_dev/basics",
    "name": "now",
    "version": "0.0.1",
    "exec": {
        "kind": "nodejs:6",
        "binary": false
    },
    "annotations": [
        {
            "key": "exec",
            "value": "nodejs:6"
        }
    ],
    "limits": {
        "timeout": 60000,
        "memory": 256,
        "logs": 10
    },
    "publish": false
}
----

However, if we try to use the URL to run the action we may have a nasty surprise:

----
$ curl https://openwhisk.eu-gb.bluemix.net/api/v1/\
namespaces/openwhisk@example.com_dev/actions/basics/now
{"error":"The resource requires authentication,\
 which was not supplied with the request" 
 "code":9814}
----

The fact is: all the actions (and everything else) in OpenWhisk is accessible with a REST API. However, by default, the actions are protected and not accessible without authentication. 

However, it is possible to mark an action as publicly accessible with the flag `--web true` flag when creating or updating it. We call them *web actions*.

A web action is supposed to produce web output so that you can view with a web browser.  There are some other constraints on Web action we discuss later. For now, focus on the fact the answer must have a `body` property that is rendered as the body of an HTML page.

Now, since our action was not a web one, we must change it. This case is an opportunity to demonstrate how the `update` command that can change an action. Then we can immediately retrieve its URL and invoke it directly.

----
$ wsk action update basics/now --web true
ok: updated action basics/now
$ curl $(wsk action get basics/now --url | tail -1)
Thu Mar 15 2018 14:46:56 GMT+0000 (UTC)
----

We saw the `create` and `update` commands for managing actions. We now complete the demonstration of the `CRUD` commands also showing the `list` and the `delete` command:


----
$ wsk action list basics
actions
/openwhisk@example.com_dev/basics/now                               private nodejs:6
$ wsk action delete basics/now
ok: deleted action basics/now
$ wsk action list basics
actions
----

==== Chain Sequences of Actions

An essential feature of OpenWhisk is the ability to chain action in sequences, creating actions that use, as an input, the output of another action, as shown in  <<sequences>>.

[id=sequences]
.Actions chained in a sequence
image::dot/sequences.dot.png[]

Let's do a practical example of a similar action sequence. We implement a word count application, separating it in two actions, put in a sequence. The first action splits the input, that is supposed to be a text file, in "words", while the second retrieves the words and produce a map as a result. In the map,  each word is then shown with its frequency.

Let's start with the first action, `split.js`, as follows:

----
function main(args) {
    let words = args.text.split(' ')
    return {
        "words": words
    }
}
----


You can deploy and test it, feeding a simple string:


----
$ wsk action update basics/split basics/split.js
ok: updated action basics/split
$ wsk action invoke basics/split \
  -p text "the pen is on the table" -r \
  | tee save.json <1>
{
    "words": [
        "the",
        "pen",
        "is",
        "on",
        "the",
        "table"
    ]
}
----
<1> note here we are saving the output in a file `save.json`


Now it is time to do the second step, with this `count.js` actions:

----
function main(args) {
    let words = args.words
    let map = {}
    let n = 0
    for(word of words) {
       n = map[word]
       map[word] = n ? n+1 : 1
    }
    return map
}
----


We can now deploy it and check the result, feeding the output of the first action as input:

----
$ wsk action update basics/count count.js
ok: updated action basics/count
$ wsk action invoke basics/count -P save.json -r
{
    "is": 1,
    "on": 1,
    "pen": 1,
    "table": 1,
    "the": 2
}
----


Now we have two actions, the second able to take the output of the first as input,  we can create a sequence:

----
wsk action update basics/wordcount \
  --sequence basics/split,basics/count <1>
----
<1> note here we are specifying a comma-separated list of existing action names

The sequence can be now invoked as a single action, so we can feed the text input and see the result:

----
$ wsk action invoke basics/wordcount -r -p text  \
"can you can a can as a canner can can a can"
{
    "a": 3,
    "as": 1,
    "can": 6,
    "canner": 1,
    "you": 1
}
----

[id=actions-including-libraries]
==== Actions including Libraries

In the simplest case, your action is just a single javascript file. However, as we are going to see, very often commonly you have some code you want to share and reuse between actions.

The best way to handle this situation is to have a library of code that you can include for every action and that you deploy with your actions.

Let's consider this example: a couple of utility functions that format a date in a standard format "YYYY/MM/DD" and time in the standard format "HH:MM:SS".


[id=format-date-time]
.Formatting date and time utility functions
----
function fmtDate(d) {
    let month = '' + (d.getMonth() + 1),
        day = '' + d.getDate(),
        year = d.getFullYear();
    if (month.length < 2) month = '0' + month;
    if (day.length < 2) day = '0' + day;
    return year + "/" + month + "/" + day
}

function fmtTime(d) {
    let hour =  ''+ d.getHours(),
        minute = '' + d.getMinutes()
        second = '' + d.getSeconds()

    if(hour.length < 2) hour = "0"+hour
    if(minute.length < 2) minute = "0"+minute
    if(second.length <2 ) second = "0"+second

    return hour + ":" + minute + ":" + second
}
----


You may, of course, copy this code in each action file, although it is pretty awkward to maintain. Just consider that when you change the function, you have to change it in all the copies of the functions across multiple files. Of course, there is a better way.


Since actions are executed using NodeJs, you have the standard export/require mechanism available for writing your actions. 


As a convention, we are going to place our shared code in a subdirectory named `lib`, and we treat them as modules. 


So you should place the <<format-date-time>> in a file `lib/datetime.js` and add at the end the following code:


----
module.exports = {
    fmtTime: fmtTime,
    fmtDate: fmtDate
}
----

Now you can use the two functions in one action. For example let consider an action named `clock` that returns the date if invoked with `date=true`, the time if invoked with `time=true`, or both if the date and time parameters are specified.


Our action will starts requiring the library with:

----
var dt = require("./lib/datetime.js")
----

This way you can access the two functions as `dt.fmtDate` and `dt.fmtTime`. Using those functions, we can easily write the main body, called `clock.js`:

----
function main(args) { 
  let now = args.millis ? new Date(args.millis) : new Date()
  let res = " "
  if(args.date)
    res = dt.fmtDate(now) + res
  if(args.time)
    res = res + dt.fmtTime(now)
  return {     
    body: res
  }
}
exports.main = main
----

Now, we have to deploy the action, but we also need to include the library. How can we do this in OpenWhisk?

The solution is to deploy not a single file but a zip file that includes all the files we want to run as a single action.

When deploying multiple files, you need either to put your code in a file `index.js` or to provide a `package.json` saying which one is the main file.

Let's perform this procedure with the following commands, creating a `package.json` inline, then a zip file and finally deploying it all. The final content of the `clock.zip` will be:

----
├── clock.js
├── lib
│   └── datetime.js
└── package.json
----

Let's build and deploy it:

----
$ cd basics
$ echo '{"main":"clock.js"}' >package.json      <1>
$ zip -r clock.zip clock.js package.json lib    <2>
$ wsk action update basics/clock clock.zip \
  --kind nodejs:6                               <3>
ok: updated action basics/clock
----
<1> creating a simple `package.json` on the fly
<2> creating a zip file with subdirectories, so the `-r` switch is required
<3> deploying the action, specifying the runtime we want to use is `nodejs:6` 

[NOTE]
When we deploy an action as a zip file, we have to specify the runtime to use with `--kind nodejs:6`,  because the system is unable to figure out by itself just from the file name.

Let's test it:

----
$ wsk action invoke basics/clock -p date true -r
{
    "body": "2018/03/18 "
}
$ wsk action invoke basics/clock -p time true -r
{
    "body": " 15:40:42"
}
----
=== Inspect Activations

In the preceding paragraph, we saw when we invoke an action without waiting for the result; we receive as an answer just an invocation id.

This fact brings us to the argument of this paragraph: the subcommand `wsk activation` to manage the results of invocations.


To explore it, let's create a simple `echo.js` file:


.A simple echo with logging for testing activations
----
function main(args) {
 console.log(args)
 return args
}
----


Now, let's deploy and invoke it (with a parameter `hello=world`) to get the activation id:

----
$ wsk action create basics/echo echo.js
ok: created action basics/echo
$ wsk action invoke basics/echo -p hello world
ok: invoked /_/basics/echo with id 82deb0ec37524a9e9eb0ec37525a9ef1
----


As we explained in Chapter 1, when actions are invoked, they are identified by an activation id, used to save and retrieve results and logs from the database.

Now, the long alphanumeric (actually, hexadecimal) identifier displayed is the activation id. We can now use with it the option `result` to get the result, and `logs` to get the logs.

----
$ ID=$(wsk action invoke basics/echo -p hello world \
  | awk '{ print $6}')
$ wsk activation result $ID
{
    "hello": "world"
}
$ wsk activation logs $ID
2018-03-15T18:17:36.551486467Z stdout: { hello: 'world' }
----

[TIP]
You can also use the `wsk result --last` to get the result of the last invoked action.

The `activation` subcommand has another two useful options. 

One is `list`. It will return a list of *all* the activations in chronological order. Since the list can be very long, it is useful always to use the option `--limit <n>` to see only the latest `<n>`:

----
$ wsk activation list --limit 4
activations
82deb0ec37524a9e9eb0ec37525a9ef1 echo
219bacbdb838449d9bacbdb838149de2 echo
1b75cd02fd1f4782b5cd02fd1f078284 echo
6fa117115aa74f90a117115aa7cf90e0 now
----

Another useful option (and probably the most useful)  is `poll`. With this option, you can continuously display logs for actions as they happen.  It is a handy option for debugging because let you to monitor what is going on in the remote serverless system.

[TIP]
You can poll for just an action or for all the actions at the same time.

=== Manage Triggers and Rules

Now let's see how to create a trigger. 

A trigger is merely a name for an arbitrary event. A trigger by itself does nothing. However with the help of rules, it becomes useful, because when a trigger is activated, it invokes all the associated rules, as shown in <<triggers>>.

[id=triggers]
.Triggers and rules
image::dot/triggers-rules.dot.png[]

Let's build now an example to see what triggers do. We use a simple action that does nothing except logging its activation. We use it to trace what is happening when you activate triggers. Note we start to construct the example now, but we complete it after we introduced rules, in the next paragraph.

So, let's prepare our example, deploying first a simple `log.js` actions, that just logs its name:

----
function main(args) {
 console.log(args.name)
 return {}
}
----

Then, we  deploy it twice, with two different names:

----
$ wsk action update basics/log-alpha -p name alpha basics/log.js
ok: updated action basics/log-alpha
$ wsk action update basics/log-beta -p name beta basics/log.js
ok: updated action basics/log-alpha
----

By themselves, those actions do nothing except leaving a trace of their activation in the logs:

----
$ wsk action invoke basics/log-alpha                 <1>
ok: invoked /_/basics/log-alpha with id 320b50d841064d0b8b50d841060d0bff
$ wsk action invoke basics/log-beta                  <2>
ok: invoked /_/basics/log-beta with id 990d284f090c45328d284f090c45320d
$ wsk activation list --limit 2                      <3>
activations 
990d284f090c45328d284f090c45320d log-beta
320b50d841064d0b8b50d841060d0bff log-alpha
$ wsk activation poll --since-seconds 60 --exit 20   <4>
Enter Ctrl-c to exit.
Polling for activation logs
Activation: 'log-beta' (e6b76a85c5584579b76a85c558957957)
[
    "2018-03-17T17:32:06.364836123Z stdout: beta"
]
Activation: 'log-alpha' (e92e4466ee8f4684ae4466ee8f6684da)
[
    "2018-03-17T17:32:00.842842699Z stdout: alpha"
]
----
<1> invoking the action `log-alpha`
<2> invoking the action `log-beta`
<3> showing a list of activations
<4> poll the activations (since 60 seconds, for 20 seconds) to see which activations happened and what they logged

Now we are ready to create a trigger, using the command `wsk trigger create` as in <<creating-trigger>>.

[NOTE]
Of course, there is not only `create` but also `update` and  `delete`, and they work as expected, updating and deleting triggers. In the next paragraph, we see also the `fire` command, that needs you first create rules to do something useful.

[id=creating-trigger]
.Creating a trigger and inspecting it
----
$ wsk trigger create basics-alert
ok: created trigger alert
$ wsk trigger list
triggers
/openwhisk@example.com_dev/basics-alert                                     private
$ wsk trigger get basics-alert
ok: got trigger alert
{
    "namespace": "openwhisk@example.com_dev",
    "name": "basics-alert",
    "version": "0.0.1",
    "limits": {},
    "publish": false
}
----

[WARNING]
Triggers are a "namespace level" entity, and you cannot put them in a package.

==== Associate Triggers to Actions with Rules

Once we have a trigger and some actions we can create rules for the trigger. A rule connects the trigger with an action, so if you fire the trigger, it will invoke the action.  Let's see in practice in next listing.

[id=creating-rules]
.An example of creating a rule, triggering an event and inspecting the logs.
----
$ wsk rule create basics-alert-alpha \
       basics-alert basics/log-alpha                      <1>
ok: created rule basics-alert-alpha
$ wsk trigger fire basics-alert                           <2>      
ok: triggered /_/alert with id 86b8d33f64b845f8b8d33f64b8f5f887
$ wsk activation logs 86b8d33f64b845f8b8d33f64b8f5f887 \  <3>
   | jq                                                   <4>
{
  "statusCode": 0,
  "success": true,
  "activationId": "b57a1f1dc3414b06ba1f1dc341ab0626",     <5>
  "rule": "openwhisk@example.com_dev/basics-alert-alpha",
  "action": "openwhisk@example.com_dev/basics/alpha"
}

$ wsk activation logs b57a1f1dc3414b06ba1f1dc341ab0626    <6>
2018-03-17T18:10:48.471777977Z stdout: alpha
----
<1> creating a rule to activate the action `basics/log-alpha` when the trigger `basics-alert` is fired
<2> we can now fire the rule, it returns an activation id
<3> let's inspect the activation id 
<4> we piped the output in the `jq` utility to make the output more readable
<5> in turn the rule invoked an action with this activation id
<6> let's see what the rule did


[NOTE]
As for all the other commands, you can execute `list, `update` and `delete` by name.

A trigger can enable multiple rules, so firing one trigger actually activates multiple actions. 

Let's try this feature. However, before starting, let's open another terminal window and enable polling (with the command `wsk activation poll`) to see what happens.

----
$ wsk rule create basics-alert-beta basics-alert basics/log-beta
ok: created rule basics-alert-beta
$ wsk trigger fire basics-alert
ok: triggered /_/basics-alert with id a731a03603bb4183b1a03603bb8183ce
----

If we check the logs we should see something like this:

----
$ wsk activation poll
Enter Ctrl-c to exit.
Polling for activation logs

Activation: 'alert' (a731a03603bb4183b1a03603bb8183ce)    <1>
[
    "{\"statusCode\":0,\"success\":true,\
    \"activationId\":\"3024596c57ac4c10a4596c57ac7c1042\",\
    \"rule\":\"openwhisk@example.com_dev/basics-alert-alpha\",\"action\":\"openwhisk@example.com_dev/basics/log-alpha\"}",
    "{\"statusCode\":0,\"success\":true,\
    \"activationId\":\"6d88836c860d405f88836c860d305f83\",\"rule\":\"openwhisk@example.com_dev/basics-alert-beta\",\
    \"action\":\"openwhisk@example.com_dev/basics/log-beta\"}"
]

Activation: 'log-alpha' (3024596c57ac4c10a4596c57ac7c1042) <2>
[
    "2018-03-17T18:34:58.633797676Z stdout: alpha"
]

Activation: 'log-beta' (6d88836c860d405f88836c860d305f83)  <3>
[
    "2018-03-17T18:34:58.629413468Z stdout: beta"
]
----
<1> The trigger activation invoked 2 actions
<2> This is the log of the first action
<3> This is the log of the second action


Rules can also be enabled and disabled without removing them. As the last example, we try to disable the first rule and fire the trigger again to see what happens. As before, first, we start the log polling to see what happened.

----
$ wsk rule disable basics-alert-alpha     <1>
ok: disabled rule basics-alert-alpha
$ wsk trigger fire basics-alert           <2>
ok: triggered /_/basics-alert with id 0f4fa69d910f4c738fa69d910f9c73af
----
<1> disabling rule alert-alpha
<2> firing the trigger again

Moreover, if we go and check the result, we see this time only the action `log-beta` was invoked.

----
$ wsk activation poll
Enter Ctrl-c to exit.
Polling for activation logs

Activation: 'basics-alert' (0f4fa69d910f4c738fa69d910f9c73af)
[
    "{\"statusCode\":0,\"success\":true,\"activationId\":\"a8221c7d7fe94e22a21c7d7fe9ce223c\",\
    \"rule\":\"openwhisk@example.com_dev/alert-beta\",\
    \"action\":\"openwhisk@example.com_dev/basics/log-beta\"}",
    "{\"statusCode\":1,\"success\":false,\
    \"rule\":\"openwhisk@example.com_dev/basics-alert-alpha\",\
    \"error\":\"Rule 'openwhisk@example.com_dev/basics-alert-alpha' is inactive, \
    action 'openwhisk@example.com_dev/basics/log-alpha' \
    was not activated.\",\
    \"action\":\"openwhisk@example.com_dev/basics/log-alpha\"}"
]

Activation: 'log-beta' (a8221c7d7fe94e22a21c7d7fe9ce223c)
[
    "2018-03-18T07:27:14.01530577Z  stdout: beta"
]
----
=== Create Feeds

Triggers are useful if someone can enable them. You can fire your triggers in code, as we will see when we examine the API. 

However triggers are really there to be invoked by third parties and hook them to our code. This feature is provided by the `feed` concept.

[id=feeds]
.Feeds triggering Actions
image::dot/feed.dot.png[]

A feed is actually an action that implements a pattern, not an API. We will see how to implement it in the example describing the "Observer" pattern. 

For now, we see how to hook an existing feed on the command line, creating a trigger invoked periodically.

For this purpose we use the `/whisk.system/alarm` package. If we inspect it, we see it offers a few actions that can be used as a periodical event source:

----
$ wsk action list /whisk.system/alarms
actions
/whisk.system/alarms/interval                                          private nodejs:6
/whisk.system/alarms/once                                              private nodejs:6
/whisk.system/alarms/alarm                                             private nodejs:6
----

The `once` feed will trigger an event only once, while the `interval` can provide it based on a fixed schedule. The `alarm` trigger is the more complex since it uses  a `cron` like expression (that we do not discuss here).

Let's create a trigger to be executed every minute  using `interval` and associate it to the rule `log-alpha`. As before, we start first the polling of the logs to see what happens.

----
$ wsk trigger create basics-interval \
  --feed /whisk.system/alarms/interval \           <1>
  --param minutes 1                                <2>
ok: invoked /whisk.system/alarms/interval with id 5d4bf01d0a56412d8bf01d0a56512d38
{
    "activationId": "5d4bf01d0a56412d8bf01d0a56512d38",
    "annotations": [
        {
            "key": "path",
            "value": "whisk.system/alarms/interval"
        },
        {
            "key": "waitTime",
            "value": 34
        },
        {
            "key": "kind",
            "value": "nodejs:6"
        },
        {
            "key": "limits",
            "value": {
                "logs": 10,
                "memory": 256,
                "timeout": 60000
            }
        },
        {
            "key": "initTime",
            "value": 320
        }
    ],
    "duration": 1153,
    "end": 1521359853176,
    "logs": [],
    "name": "basics-interval",
    "namespace": "openwhisk@example.com_dev",
    "publish": false,
    "response": {
        "result": {
            "status": "success"
        },
        "status": "success",
        "success": true
    },
    "start": 1521359852023,
    "subject": "openwhisk@example.com",
    "version": "0.0.6"
}
ok: created trigger interval

$ wsk rule create \                                 <3>
  basics-interval-alpha basics-interval basics/log-alpha
ok: created rule interval-alpha
----
<1> the parameter `--feed`  connects the trigger to the feed
<2> we pass a parameter to the feed, saying we want the trigger to be activated every minute
<3> the trigger does nothing until we associate it to action with a rule

If we now wait a couple of minutes this is what we will see in the activation log:

----
Polling for activation logs:

Activation: 'log-alpha' (0ca4ade11e73498fa4ade11e73a98ff0)
[
    "2018-03-18T08:01:03.046752324Z stdout: alpha"
]

Activation: 'basics-interval' (065c363456b440489c363456b4c04864)
[
    "{\"statusCode\":0,\"success\":true,\"activationId\":\"0ca4ade11e73498fa4ade11e73a98ff0\",\"rule\":\"openwhisk@example.com_dev/basics-interval-alpha\",\"action\":\"openwhisk@example.com_dev/basics/log-alpha\"}"
]
----

[WARNING]
After you do this test, do not forget to remove the trigger or it will stay there forever, consuming actions. You may even end up getting a bill for it! 

To remove the trigger and the rule:

----
$ wsk rule delete basics-interval-alpha
ok: deleted rule interval-alpha
$ wsk trigger delete basics-interval
ok: deleted trigger interval
----
